/*
 * apple2.dec.c
 */

#include "vm_segment.h"

static vm_8bit table[] = {
    0x68, 0xa2, 0x5e, 0x5f, 0xff, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0xa2, 0x5e, 0x5f, 0xff, 0x7f, 0x00, 0x00, 0x49, 0x62, 0x4f, 0x10, 0x01, 0x00, 0x00, 0x00,
    0x40, 0xa2, 0x5e, 0x5f, 0xff, 0x7f, 0x00, 0x00, 0x40, 0xa2, 0x5e, 0x5f, 0xff, 0x7f, 0x00, 0x00,
    0x58, 0xa2, 0x5e, 0x5f, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x50, 0x61, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x55, 0x4f, 0x10, 0x01, 0x00, 0x00, 0x00,
    0xc0, 0x54, 0x4f, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

#if 0
/*
 * This is the "reverse" gcr table from enc.c; given one of the disk
 * bytes, this table can turn them back into a 6-bit byte.
 */
static vm_8bit rev62[] = {
//  00    01    02    03    04    05    06    07    08    09    0a    0b    0c    0d    0e    0f 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 00
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 10
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 20
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 30
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 40
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 50
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 60
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 70
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 80
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x03, 0x00, 0x04, 0x05, 0x06, // 90
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, // a0
    0x00, 0x00, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x00, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, // b0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x1c, 0x1e, 0x1e, // c0
    0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x20, 0x21, 0x00, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, // d0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x2a, 0x2b, 0x00, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, // e0
    0x00, 0x00, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x00, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, // f0
};
#endif

#if 0
int
apple2_dec_sector(vm_segment *dest, vm_segment *src, int doff, int soff)
{
    int i, orig;
    vm_8bit xoff;
    vm_8bit conv[0x157], xor[0x156];
    vm_8bit lval;

    orig = doff;

    for (i = 0; i < 0x157; i++) {
        conv[i] = table[vm_segment_get(src, soff + i) & 0x7f];
    }

    for (i = 0, lval = 0; i < 0x156; i++) {
        xor[i] = lval ^ conv[i];
        lval = xor[i];
    }

    xoff = 0xac;
    i = 0;
    while (xoff != 0x02) {
        if (xoff >= 0xac) {
            vm_segment_set(dest, doff + xoff, 
                           (xor[xoff + 0x56] & 0xfc) | ((xor[i] & 0x80) >> 7) | ((xor[i] & 0x40) >> 5));
        }

        xoff -= 0x56;
        vm_segment_set(dest, doff + xoff,
                       (xor[xoff + 0x56] & 0xfc) | ((xor[i] & 0x20) >> 5) | ((xor[i] & 0x10) >> 3));

        xoff -= 0x56;
        vm_segment_set(dest, doff + xoff,
                       (xor[xoff + 0x56] & 0xfc) | ((xor[i] & 0x08) >> 3) | ((xor[i] & 0x04) >> 1));

        xoff -= 0x53;
        i++;
    }

#if 0
    for (i = 0; i < 0x56; i++) {
        vm_8bit vac, v56, v00, 
                offac, off56;

        offac = i + 0xAC;
        off56 = i + 0x56;

        vac = (xor[offac + 0x56] & 0xfc) | ((xor[i] & 0x80) >> 7) | ((xor[i] & 0x40) >> 5);
        v56 = (xor[off56 + 0x56] & 0xfc) | ((xor[i] & 0x20) >> 5) | ((xor[i] & 0x10) >> 3);
        v00 = (xor[i + 0x56] & 0xfc) | ((xor[i] & 0x08) >> 3) | ((xor[i] & 0x04) >> 1);

        if (i == 0) {
            printf("vac = %02x, v56 = %02x, v00 = %02x\n", vac, v56, v00);
        }

        if (offac > 0xAC) {
            vm_segment_set(dest, doff + offac, vac);
        }

        vm_segment_set(dest, doff + off56, v56);
        vm_segment_set(dest, doff + i, v00);
    }
#endif

    return 256;
}
#endif

int
apple2_dec_sector(vm_segment *dest, vm_segment *src, int doff, int soff)
{
    vm_8bit data[500];
    int i;

    int prologue = soff;
    int epilogue = soff + 9 + 0x157;

    // Let's validate that there's really a sector where we think
    // there's one.
    if (vm_segment_get(src, prologue) != 0xd5 ||
        vm_segment_get(src, prologue + 1) != 0xaa ||
        vm_segment_get(src, prologue + 2) != 0xad ||
        vm_segment_get(src, epilogue) != 0xde ||
        vm_segment_get(src, epilogue + 1) != 0xaa ||
        vm_segment_get(src, epilogue + 2) != 0xeb
       ) {
        return 0;
    }

    // We want to start with just the data field from the encoded
    // sector; this means stripping out any metadata and self-sync
    // bytes.
    for (i = soff + 9; i < epilogue; i++) {
        data[i - soff - 9] = vm_segment_get(src, i);
    }
    
    return 256;
}
